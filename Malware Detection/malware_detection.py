import os
import hashlib
import subprocess
import json
from datetime import datetime

# Function to calculate file hash (SHA256)
def calculate_file_hash(file_path):
    hash_sha256 = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha256.update(chunk)
    return hash_sha256.hexdigest()

# Function to monitor file system changes
def monitor_file_changes(directory):
    snapshot = {}
    for root, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            snapshot[file_path] = calculate_file_hash(file_path)
    return snapshot

# Function to detect changes in file hashes
def detect_changes(old_snapshot, new_snapshot):
    changes = {"added": [], "removed": [], "modified": []}

    for file in old_snapshot:
        if file not in new_snapshot:
            changes["removed"].append(file)
        elif old_snapshot[file] != new_snapshot[file]:
            changes["modified"].append(file)

    for file in new_snapshot:
        if file not in old_snapshot:
            changes["added"].append(file)

    return changes

# Function to execute a sample in a sandboxed environment
def execute_sample(sample_path, sandbox_path):
    try:
        # Copy sample to sandbox
        sandbox_sample_path = os.path.join(sandbox_path, os.path.basename(sample_path))
        subprocess.run(["cp", sample_path, sandbox_sample_path], check=True)

        # Execute sample
        process = subprocess.Popen(["/usr/bin/env", "python3", sandbox_sample_path],
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        # Log output
        execution_log = {
            "timestamp": datetime.now().isoformat(),
            "stdout": stdout.decode(),
            "stderr": stderr.decode(),
        }
        log_file = os.path.join(sandbox_path, "execution_log.json")
        with open(log_file, "w") as log:
            json.dump(execution_log, log, indent=4)

        return execution_log

    except Exception as e:
        return {"error": str(e)}

# Function to analyze behaviors and log results
def analyze_behavior(log_path):
    try:
        with open(log_path, "r") as log_file:
            logs = json.load(log_file)

        # Placeholder: Replace with specific analysis logic
        if "malicious" in logs.get("stderr", ""):
            return "Potential malicious behavior detected."
        else:
            return "No malicious behavior detected."

    except Exception as e:
        return f"Error during analysis: {str(e)}"

# Main workflow
def main():
    monitored_dir = "./monitored"
    sandbox_dir = "./sandbox"
    sample_file = "./samples/sample.py"

    # Ensure sandbox directory exists
    os.makedirs(sandbox_dir, exist_ok=True)

    # Take initial snapshot
    initial_snapshot = monitor_file_changes(monitored_dir)

    # Execute malware sample
    execution_results = execute_sample(sample_file, sandbox_dir)
    print("Execution Results:", execution_results)

    # Analyze behavior
    log_file = os.path.join(sandbox_dir, "execution_log.json")
    analysis_results = analyze_behavior(log_file)
    print("Analysis Results:", analysis_results)

    # Take new snapshot and detect changes
    new_snapshot = monitor_file_changes(monitored_dir)
    changes = detect_changes(initial_snapshot, new_snapshot)
    print("File System Changes:", changes)

if __name__ == "__main__":
    main()
